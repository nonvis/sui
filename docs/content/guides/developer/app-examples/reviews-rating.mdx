---
title: Reviews Rating
---

The following documentation goes through an example implementation of a review rating platform for the services wanted to built more transparent post-service review dapp top on the Sui protocol.
This example shows to possbility unlike traditional review rating platforms which is not disclose the algorithm used to rate reviews, the on-chain platform uses an algorithm that is published on-chain for everyone to see and verify.
Furthermore, all submitted reviews are scored and ordered on-chain which is feasible due to the low gas cost of computation on Sui.

## Personas

There are four actors in the typical workflow of the reviews rating example.

```mermaid
sequenceDiagram
  Service ->> Dashboard: Add service to dashboard.
  Service ->> User: Send proof of experience.
  User ->> Service: Send review
  Service ->> User: Send reward
  Service ->> Moderator: Add as a service moderator
  Moderator ->> Service: Remove abused review
```

### Service owners

Service owners are entities like restaurants that list their services on the platform. They want to attract more customers by receiving high-rated reviews for their services.

Service owners allocate a specific amount of SUI as a reward pool. Assets from the pool are used to provide rewards for high-rated reviews. A Proof of Experience (PoE) NFT confirms a reviewer used the service, which the reviewer can burn later to provide a verified review. Service owners provide their customers with unique identifiers, perhaps using QR codes, to identify individual reviewers.

### Reviewers

Reviewers are consumers of services that use the review system. Reviewers provide feedback in the form of comments that detail specific aspects of the service as well as a star rating to inform others. The reviews are rated, with the most effective reviews getting the highest rating. Service owners award the 10 highest rated reviews for their service. How often the rewards are distributed is up to the service owner's discretion; for example, the rewards can be distributed once a week or once a month.

### Review readers

Review readers access reviews to make informed decisions on selecting services. Readers rate reviews by casting up or down votes. The review readers' ratings are factored into the algorithm that rates the reviews, with the authors of the highest-rated reviews getting rewarded. Although it is not implemented as part of this guide, a proportion of the review rewards may be awarded to review readers who has participated in rating reviews by casting their votes.

### Moderators

Moderators monitor content of the reviews and can delete any reviews that contain inappropriate content.

The incentive mechanism for moderators is not implemented for this guide, but service owners can all pay into a pool that goes to moderators, on a rolling basis. People can stake moderators to influence what proportion of the reward each moderator gets, up to a limit (imagine how validators are staked on-chain), and moderator decisions are decided by quorum of stake weight. This is a way to ensure that moderators have incentives to do their job well.

## How reviews are rated

The reviews are rated (scored) on-chain using following criteria in this app like below;

- Intrinsic score (IS)
  - Length of review content
- Extrinsic score (ES)
  - Number of votes a review received
- Verification multiplier (VM)
  - Reviews with PoE (Proof of Experience) socre get a multiplier to improve rating

```
Total Score = (IS + ES) * VM
```

## Smart contracts

There are several modules that create the backend logic for the example.

### dashboard.move

The `dashboard.move` module defines the `Dashboard` struct that is used to group services.

```move
struct Dashboard has key, store {
    id: UID,
    service_type: String
}
```

The services are grouped by attributes, which can be cuisine type, geographical location, operating hours, google maps ID, and so on. To keep it basic, the example stores only `service_type` (for example, fast food, Chinese, Italian).

```move
public entry fun create_dashboard(
    service_type: String,
    ctx: &mut TxContext,
) {
    let db = Dashboard {
        id: object::new(ctx),
        service_type
    };
    transfer::share_object(db);
}

public fun register_service(db: &mut Dashboard, service_id: ID) {
    df::add(&mut db.id, service_id, service_id);
}
```

A `Dashboard` is a [shared object](../../../concepts/object-ownership/shared.mdx), so any service owner can register his/her service to a dashboard.
And a [dynamic field](../../../concepts/dynamic-fields.mdx) is used to store the list of services that are registered to a dashboard.
:::info

See [Shared versus Owned Objects](../sui-101/shared-owned.mdx) for more information on the differences between object types.

:::

### service.move

This module defines the `Service` struct, which service owners manage.

```move
const MAX_REVIEWERS_TO_REWARD: u64 = 10;

struct Service has key, store {
    id: UID,
    reward_pool: Balance<SUI>,
    reward: u64,
    top_reviews: vector<ID>,
    reviews: ObjectTable<ID, Review>,
    overall_rate: u64,
    name: String
}
```

#### Reward distribution
The same amount is rewarded to top reviewers, and the reward is distributed to Top 10 reviews  at most.
`SUI` tokens acted as reward that will be distributed to reviewers is stored in `reward_pool` field, and the amount of `SUI` tokens that will be awarded to each participant is configured in `reward` field.

### review.move

`Review` struct defines on review.move.

In addition to the content of a review, all the elements that are required to compute total score are stored in a `Review` object.

And `Review` is a [shared object](../../../concepts/object-ownership/shared.mdx), so anyone can cast a vote on a review and update its `total_score` field.
After `total_score` is updated, the [`update_top_reviews`](#casting-votes) function can be called to update the `top_reviews` field of the `Service` object.

```move
struct Review has key, store {
    id: UID,
    owner: address,
    service_id: ID,
    content: String,
    // intrinsic score
    len: u64,
    // extrinsic score
    votes: u64,
    time_issued: u64,
    // proof of experience
    has_poe: bool,
    total_score: u64,
    overall_rate: u8,
}
```

#### Storage for reviews
Since anyone can submit a review for a service, a `Service` should be defined as a shared object.
All the reviews are stored in `reviews` field, which has [ObjectTable](../../../concepts/sui-move-concepts/collections.mdx#object_table)`<ID, Review>` type.
Note that `reviews` are stored as children of the shared object, but they are still accessible by their `ID`.
:::info

See [Table and Bag](../../../concepts/dynamic-fields/tables-bags.mdx) for more information on the differences between `Table` and `ObjectTable`.

:::

The top rated reviews are stored in `top_reviews` field, which has `vector<ID>` type.
A simple vector can be used to store the top rated reviews because the maximum number of reviews that can be rewarded is 10.
The elements of `top_reviews` are sorted by the `total_score` of the reviews, with the highest rated reviews coming first, and contain
the `ID` of the reviews (whose content and vote count can be looked up from the `reviews`).

#### Casting votes

Through the casting vote processes like below, we could watch how reviews will be rated on chain.

```move
public fun upvote(service: &mut Service, review_id: ID) {
    let review = object_table::borrow_mut(&mut service.reviews, review_id);
    review::upvote(review);
    reorder(service, review_id, review::get_total_score(review));
}

public fun downvote(service: &mut Service, review_id: ID) {
    let review = object_table::borrow_mut(&mut service.reviews, review_id);
    review::downvote(review);
    reorder(service, review_id, review::get_total_score(review));
}

fun reorder(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    let (contains, idx) = vector::index_of(&service.top_reviews, &review_id);
    if (!contains) {
        update_top_reviews(service, review_id, total_score);
    } else {
        vector::remove(&mut service.top_reviews, idx);
        let idx = find_idx(service, total_score);
        vector::insert(&mut service.top_reviews, review_id, idx);
    }
}

fun update_top_reviews(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    if (should_update_top_reviews(service, total_score)) {
        let idx = find_idx(service, total_score);
        vector::insert(&mut service.top_reviews, review_id, idx);
        prune_top_reviews(service);
    };
}

fun find_idx(service: &Service, total_score: u64): u64 {
    let idx = 0;
    let len = vector::length(&service.top_reviews);
    while (idx < len) {
        let review_id = *vector::borrow(&service.top_reviews, idx);
        if (get_total_score(service, review_id) < total_score) {
            break
        };
        idx = idx + 1;
    };
    idx
}
```

Whenever someone casts a vote on a review, the `total_score` of the review is updated, and the `top_reviews` field can be updated by calling the `update_top_reviews` function.
Note that casting a vote also triggers a reordering of the `top_reviews` field to ensure that the top rated reviews are always at the top.

#### Authorization
```move
struct AdminCap has key, store {
    id: UID,
    service_id: ID
}
struct Moderator has key {
    id: UID,
}
```

This example follows a [capabilities pattern](../../../concepts/sui-move-concepts/patterns/capabilities.mdx) to manage authorizations.
For example, `SERVICE OWNERS` are given `AdminCap` and `MODERATORS` are given `Moderator` such that only they are allowed to perform privileged operations.

## Deployment

Navigate to the [setup folder](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/setup) of the repository and execute the `publish.sh` script. Refer to the [README instructions](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/README.md) for deploying the smart contracts.

## Frontend
The frontend module is written in React, and is structured to provide a responsive user experience for interacting with a review rating platform.
On the [`page` component](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/page.tsx), a user can be logged in as a `SERVICE OWNER`, a `MODERATOR`, or a `REVIEWER`.

### Directories structure

The frontend is a NextJS project, that follows the NextJS App Router [project structure](https://nextjs.org/docs/app/building-your-application/routing).
The main code of the frontend lies under the [app/src/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/) directory.
The main sub-directories are:
  - [app/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/): The main code of the pages and the global styles.
  - [components/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/components): The reusable components of the app, organized in sub-directories.
  - [hooks/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/hooks): The custom hooks used in the app.
  - [moderator/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/moderator): The pages for `MODERATOR`.
  - [serviceOwner/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/serviceOwner): The pages for `SERVICE OWNER`.
  - [types/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/types): The types/interfaces used in the app.
  - [user/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/user): The pages for `REVIEWER`.

### Connect button

The Wallet Kit comes with a pre-built React.js component called `ConnectButton` displaying a button to connect and disconnect a wallet. The connecting and disconnecting wallet logic is handled seamlessly so you don't need to worry about repeating yourself doing the same logic all over again.

Place the `ConnectButton` in the Navigation bar to allow users to connect their wallets:

```ts title='src/app/components/navbar/Navbar.tsx'
import { ConnectButton } from "@mysten/wallet-kit";
import { usePathname } from "next/navigation";
import { useAuthentication } from "@/app/hooks/useAuthentication";

export const Navbar = () => {
  const pathname = usePathname();
  console.log(pathname);
  const { user, handleLogout } = useAuthentication();

  return (
    <div
      className="grid grid-cols-12 w-full items-center p-[8px] h-[80px] border-b-gray-400 border-b-[1px] sticky top-0"
      style={{
        background: "white",
      }}
    >
      <div className="col-span-3 flex space-x-3 items-center">
        <div
          className="text-red-600 text-2xl font-bold cursor-pointer"
          onClick={handleLogout}
        >
          Restaurant Reviews
        </div>
      </div>

      <div className="col-span-6 flex space-x-3 justify-center">
        {pathname !== "/" && (
          <h6 className="mb-4 text-2xl leading-none tracking-tight text-gray-400">
            logged in as{" "}
            <span className="underline underline-offset-3 decoration-8 decoration-blue-400 dark:decoration-blue-600">
              {user.role === "user" && "USER"}
              {user.role === "serviceOwner" && "SERVICE OWNER"}
              {user.role === "moderator" && "MODERATOR"}
            </span>
          </h6>
        )}
      </div>

      <div className="col-span-3 flex justify-end gap-[14px]">
        <ConnectButton />
      </div>
    </div>
  );
};

```
### Type definitions
All the type definitions are in `src/app/types/`.

`Review` and `Service` represent the review and service objects.

```ts title='src/app/types/Review.ts'
export interface Review {
    id: string;
    owner: string;
    service_id: string;
    content: string;
    len: number;
    votes: number;
    time_issued: number;
    has_poe: boolean;
    total_score: number;
}
```
```ts title='src/app/types/Service.ts'
export interface Service {
  id: string;
  name: string;
  stars: number;
  reward?: number;
  pool?: number;
}
```

### Execute transaction hook

In the frontend, you might need to execute a transaction block in multiple places, hence it's better to extract the transaction execution logic and reuse it everywhere. Let's examine the execute transaction hook.
```ts title='src/app/hooks/useSignAndExecuteTransaction.ts'
import { useWalletKit } from "@mysten/wallet-kit"
import { toast } from "react-hot-toast";
import { useSui } from "./useSui";
import { TransactionBlock } from "@mysten/sui.js/transactions";

export const useSignAndExecuteTransaction = () => {
    const { executeSignedTransactionBlock } = useSui();
    const { signTransactionBlock } = useWalletKit();
    const handleSignAndExecuteTransaction = async (
        tx: TransactionBlock,
        operation: String,
        setIsLoading: any
    ) => {
        return signTransactionBlock({
            transactionBlock: tx,
        }).then((signedTx: any) => {
            return executeSignedTransactionBlock({
                signedTx,
                requestType: "WaitForLocalExecution",
                options: {
                    showEffects: true,
                    showEvents: true,
                },
            }).then((resp) => {
                setIsLoading(false);
                console.log(resp);
                if (resp.effects?.status.status === "success") {
                    console.log(`${operation} operation successful`);
                    toast.success(`${operation} operation successful`);
                    return
                } else {
                    console.log(`${operation} operation failed`);
                    toast.error(`${operation} operation failed.`);
                    return
                }
            }).catch((err) => {
                setIsLoading(false);
                console.log(`${operation} operation failed`);
                console.log(`${operation} error : `,err);
                toast.error(`Something went wrong, ${operation} operation failed.`);
            });
        }).catch((err) => {
            setIsLoading(false);
            console.log(`signing goes wrong ${operation} error : `,err);
            toast.error(`signing goes wrong, ${operation} operation failed.`);
        });
    }
    return { handleSignAndExecuteTransaction }
}
```
The hook logic is straightforward. A `TransactionBlock` is the input, sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.

Use the `useWalletKit()` hook from `wallet Kit` to retrieve the Sui client instance configured in `WalletKitProvider`. The `signTransactionBlock()` function is another hook that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, the `executeSignedTransactionBlock()` on the Sui client instance of the Sui TypeScript SDK. Use `react-hot-toast` as another dependency to toast transaction status to users.

### Components and custom hooks for state management

- **Custom Hooks:** To keep the code as structured as possible, multiple custom hooks are utilized to manage the list of reviews associated with a service. The [useGetReviews](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useGetReviews.ts)
custom hook encapsulates the service, exposing all the required information (with fields such as `nameOfService`, `listOfReviews`, `listOfStars`) to display the reviews in a table.
Multiple additional custom hooks, such as [useDashboardCreation](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useDashboardCreation.ts), and [useServiceReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServiceReview.ts) are encapsulating their own piece of state and logic to make the code readable and maintainable.

- **Component for Adding a New Review:** The [AddReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/components/review/AddReview.tsx) component is implemented to facilitate the creation of a new review. It is rendered by the [servicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/service/[id]/page.tsx) to collect a review entry from a `USER` and uses the `signAndExecuteTransactionBlock` function of the [useWalletKit] hook to execute the transaction.

- **Proof of Experience Generation:** Proof of Experience(PoE) is an NFT that is minted by `SERVICE OWNER` for customers after they dine at the restaurant; customers can, then, burn the PoE to write a high-rated review later. Minting an NFT is facilitated by the [ownedServicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/serviceOwner/ownedServices/page.tsx) component. This component is using the [useServicePoEGeneration](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServicePoeGeneration.ts) custom hook.

- **Delete a Review:** The moderator can delete a review that contain inappropriate content. [moderatorRemovePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/moderator/remove/[id]/[nft]/page.tsx) component is used to delete a review.

:::info

The complete app example can be found in [the reviews-rating repo](https://github.com/MystenLabs/reviews-ratings-poc).

:::
